<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AYYO Client</title>
  <script src="/vendor/jquery.min.js"></script>
  <script src="/vendor/babylon.js"></script>
  <script src="/vendor/babylon.gui.min.js"></script>
  <script src="/vendor/babylonjs.materials.min.js"></script>
  <script src="/vendor/phaser.min.js"></script>
  <!--  TODO: separate HTML files for phaser, jquery, etc -->

  <style>
    #output {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 20px;
    }

    #renderCanvas {
      top: 0;
      left: 0;
      z-index: -1;
    }

    #debugUIContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 98vw;
      height: 50vw;
      overflow-y: scroll;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      color: white;
      z-index: 9999;
    }

    #gameHolder {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <canvas id="renderCanvas"></canvas>
  <script type="text/javascript">

  </script>
  <script type="module" src="/mantra.head.bundle.js"></script>
  <script>

    setTimeout(function () {
      let game = new MANTRA.Game({
        height: 600,
        width: 800,
        isClient: true
      });
      let Plugins = MANTRA.plugins;

      //
      // Use Plugins to add systems to the game
      //
      game
        .use(new Plugins.MatterPhysics())
        .use(new Plugins.Collision())
        .use(new Plugins.EntityFactory())
        .use(new Plugins.EntityInput())
        .use(new Plugins.EntityMovement(new Plugins.PongMovement()))
        .use(new Plugins.Bullet())
        .use(new Plugins.Border());

      //
      // Since this is the Client, we can add a Graphics Plugin
      //
      game
        .use(new Plugins.Graphics()) // adds Game.createGraphic, game.removeGraphic, game.createTriangle, game.systems.graphics, etc
        .use(new Plugins.BabylonGraphics())  // BabylonGraphics will now recieve game.createGraphic, game.removeGraphic, etc
        .use(new Plugins.PhaserGraphics()) // We can register multiple Graphics Plugins and each will recieve the same game.createGraphic, etc
        .use(new Plugins.Camera())
        .use(new Plugins.StarField())
        .use(new Plugins.KeyboardBrowser())
        .use(new Plugins.LocalClient('Bobby'));

      game.createEntity({
        id: "Bobby",
        type: 'PLAYER',
        shape: 'rectangle',
        restitution: 0, // bounciness
        mass: 90000,
        height: 300,
        width: 40,
        friction: 0,  // Default friction
        frictionAir: 0, // Default air friction
        frictionStatic: 0, // Default static friction
        lockedProperties: {
          position: {
            x: 0
          }
        }
      });

      game.createEntity({
        id: 'game-ball',
        type: 'BALL',
        x: 0,
        y: 500,
        height: 50,
        width: 50,
        velocity: { // set initial velocity
          x: 8,
          y: 8
        },
        maxSpeed: 20,
        restitution: 2.5, // bounciness
        friction: 0,  // Default friction
        frictionAir: 0, // Default air friction
        frictionStatic: 0, // Default static friction
      });

      /*
      game.createEntity({
        type: 'BORDER',
        shape: 'rectangle',
        isStatic: true,
        position: {
          x: 1000,
          y: 0
        },
        width: 1000,
        height: 100,
        thickness: 30
      });
      */

      game.on('collisionStart', ({ pair, bodyA, bodyB }) => {
        // check to see if ball and left or right walls, if so goal
        console.log('collisionStart', bodyA.entity, bodyB.entity)
        if (!bodyA.entity || !bodyB.entity) {
          return;
        }

        if (bodyA.entity.type === 'BORDER' && bodyB.entity.type === 'BALL') {

          /*
          let invertedVelocity = {
            x: bodyB.entity.velocity.x * 1.2,
            y: bodyB.entity.velocity.y * 1.2
          }
      
          if (bodyB.entity.velocity.x === 0 && bodyB.entity.velocity.y === 0) {
            invertedVelocity = {
              x: bodyB.entity.velocity.x,
              y: bodyB.entity.velocity.y * -1.2
            }
          }
    
          if (bodyA.entity.id === 'border-left' || bodyA.entity.id === 'border-right') {
            console.log(bodyA.entity.id)
            console.log('setVelocity', bodyB.entity, invertedVelocity)
            let resetPosition = {
              x: 0,
              y: 0
            };
            //game.physics.setPosition(bodyB, resetPosition)
            // game.components.position.set(bodyB.entity.id, resetPosition);
    
          }
          */

          // game.components.velocity.set(bodyB.entity.id, invertedVelocity);
          // attempt to ovveride anyway
          /*
          game.components.velocity.set(bodyB.entity.id, {
            x: -10,
            y: -10
          });
          */
          // console.log('current V', bodyA.velocity)

        }



      })

      game.on('collisionActive', (event) => {
        console.log('collisionActive', event)
      })

      game.on('collisionEnd', (event) => {
        console.log('collisionEnd', event)
      })




      game.start();


    }, 400)




  </script>
</body>

</html>